import json
from pathlib import Path
import glob
from astropy.io import fits
import os
import cv2
import numpy as np
from detectron2.structures import BoxMode
from astropy.visualization import make_lupton_rgb


class DataLoader:
    """A base data loader class"""

    def __init__(self):
        self.filedict = None
        self.dataset_dicts = None

    def get_dataset_dicts(self):
        """retrieves the list of dataset_dicts if established."""
        return self.dataset_dicts

    def generate_filedict(
        self, dirpath, filters, img_files, mask_files, subdirs=False, filt_loc=0, n_samples=None
    ):
        """Generates a path dictionary from a directory of files.

        Parameters
        ----------
        dirpath : str, path-like
            The path to the data directory.
        filters : list
            A list of filters available in the dataset. The filter names should
            match some string identifier in the name itself. E.g. img_r.fits
            will be matched to a filter with label "r"
        img_files: str
            The name of the image files to collect, should have a "*" to
            collect all image files in the dataset. E.g. 001_img.fits can be
            caught used img_files = "*_img.fits"
        maskfiles: str
            The name of the mask files to collect, should have a "*" to
            collect all mask files in the dataset. E.g. 001_mask.fits can be
            caught used mask_files = "*_mask.fits"
        subdirs: bool
            Indicates whether the data is stored within subdirectories within
            the dirpath. If True, will recursively search for files.
        filt_loc: int
            The integer location of the filter within the image name, used to
            split files across filters accordingly. E.g. 001_img_r.fits would
            have a filt_loc of 8 (or -6). Editorial Note: This is rough
        n_samples: int
            If specified, filters down to a subset of the dataset that contains
            `n_samples` image files per filter.

        """

        # Setup filenames dict
        filenames_dict = {}
        filenames_dict["filters"] = filters

        # Glob in filenames from the paths
        if subdirs:
            imgs = sorted(glob.glob(os.path.join(dirpath, "*", img_files)))
            masks = sorted(glob.glob(os.path.join(dirpath, "*", mask_files)))
        else:
            imgs = sorted(glob.glob(os.path.join(dirpath, img_files)))
            masks = sorted(glob.glob(os.path.join(dirpath, mask_files)))

        # Assign files to the dictionary by filter
        # Requires good assignment of the img_files and filt_loc parameters
        for filt in filenames_dict["filters"]:
            filenames_dict[filt] = {}

            if n_samples:
                filenames_dict[filt]["img"] = [f for f in imgs if f.split("/")[-1][filt_loc] == filt][
                    0:n_samples
                ]
            else:
                filenames_dict[filt]["img"] = [f for f in imgs if f.split("/")[-1][filt_loc] == filt]

        if n_samples:
            masks = masks[0:n_samples]
        filenames_dict["mask"] = masks

        # Store the result in a class property for future use.
        self.filedict = filenames_dict

        return self

    def generate_dataset_dict(self, func, filedict=None, **kwargs):
        """Generates a list of dictionaries using a user-defined annotation
        generator function on each image file/mask. The format is determined
        by the user defined function

        Parameters
        ----------
        func: function
            A user-defined function that operates on a set of images and a mask
            file to generate a dictionary of annotations. The DataLoader
            expects this function to take in kwargs as follows
            (image_files, mask_file, **kwargs), where image files is a list of
            paths to image filenames (each image corresponds to one band) and
            mask_file points to a single mask filename.
        filedict: dict
            A dictionary with image and mask filepaths defined, generated by
            `DataLoader.generate_filedict`. If not specified, attempts to use
            a filedict stored within the `DataLoader` instance.


        """
        if filedict is None:
            if self.filedict is None:
                raise ValueError("No file dictionary has been provided.")
            else:
                filedict = self.filedict

        # Group images by filter
        img_files = np.transpose([filedict[filt]["img"] for filt in filedict["filters"]])

        # Initialize data dictionary
        dataset_dicts = []

        # Use user-provided function to generate a dictionary record per image set
        for images, mask in zip(img_files, filedict["mask"]):
            record = func(images, mask, **kwargs)

            # Add records to the data_dict
            dataset_dicts.append(record)

        self.dataset_dicts = dataset_dicts
        return self

    def load_coco_json_file(self, file):
        """Open a JSON text file, and return encoded data as dictionary.

        Assumes JSON data is in the COCO format.

        Parameters
        ----------
        file : str
            pointer to file

        Returns
        -------
            dictionary of encoded data
        """
        # Opening JSON file
        with open(file, "r", encoding="utf-8") as f:
            data = json.load(f)

        self.dataset_dicts = data
        return self


def get_data_from_json(filename):
    """Open a JSON text file, and return encoded data as dictionary.

    Parameters
    ----------
    filename : str
        The name of the file to load.

    Returns
    -------
        dictionary of encoded data

    Raises
    ------
    FileNotFoundError if the file cannot be found.
    """
    if not Path(filename).exists():
        raise FileNotFoundError(f"Unable to load file {filename}")

    # Opening JSON file
    with open(filename, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data


class ImageReader:
    """Class that will read images on the fly for the training/testing dataloaders"""

    def __init__(self, reader, norm="raw", **scalekwargs):
        """
        Parameters
        ----------
        reader : function
            This function should take a single key and return a single image as a numpy array
            ex) give a filename or an index in an array
        norm : str
            A contrast scaling to apply before data augmentation, i.e. luptonizing or z-score scaling
            Default = raw
        **scalekwargs : key word args
            Key word args for the contrast scaling function
        """
        self.reader = reader
        self.scalekwargs = scalekwargs
        self.scaling = ImageReader.norm_dict[norm]

    def __call__(self, key):
        """Read the image and apply scaling.

        Parameters
        ----------
        key : str or int
            The key indicating the image to read.

        Returns
        -------
        im : numpy array
            The image.
        """
        im = self.reader(key)
        im_scale = self.scaling(im, **self.scalekwargs)
        return im_scale

    def raw(im):
        """Apply raw image scaling (no scaling done).

        Parameters
        ----------
        im : numpy array
            The image.

        Returns
        -------
        numpy array
            The image with pixels as float32.
        """
        return im.astype(np.float32)

    def lupton(im, bandlist=[2, 1, 0], stretch=0.5, Q=10, m=0):
        """Apply Lupton scaling to the image and return the scaled image.

        Parameters
        ----------
        im : np array
            The image being scaled
        bandlist : list[int]
            Which bands to use for lupton scaling (must be 3)
        stretch : float
            lupton stretch parameter
        Q : float
            lupton Q parameter
        m: float
            lupton minimum parameter

        Returns
        -------
        image : numpy array
            The 3-channel image after lupton scaling using astropy make_lupton_rgb
        """
        assert np.array(im.shape).argmin() == 2 and len(bandlist) == 3
        b1 = im[:, :, bandlist[0]]
        b2 = im[:, :, bandlist[1]]
        b3 = im[:, :, bandlist[2]]

        image = make_lupton_rgb(b1, b2, b3, minimum=m, stretch=stretch, Q=Q)
        return image

    def zscore(im, A=1):
        """Apply z-score scaling to the image and return the scaled image.

        Parameters
        ----------
        im : np array
            The image being scaled
        A : float
            A multiplicative scaling factor applied to each band

        Returns
        -------
        image : numpy array
            The image after z-score scaling (subtract mean and divide by std deviation)
        """
        I = np.mean(im, axis=-1)
        Imean = np.nanmean(I)
        Isigma = np.nanstd(I)

        for i in range(im.shape[-1]):
            image[:, :, i] = A * (im[:, :, i] - Imean - m) / Isigma

        return image

    # This dict is created to map an input string to a scaling function
    norm_dict = {"raw": raw, "lupton": lupton}

    @classmethod
    def add_scaling(cls, name, func):
        """Add a custom contrast scaling function

        ex)
        def sqrt(image):
            image[:,:,0] = np.sqrt(image[:,:,0])
            image[:,:,1] = np.sqrt(image[:,:,1])
            image[:,:,2] = np.sqrt(image[:,:,2])
            return image

        ImageReader.add_scaling('sqrt',sqrt)
        """
        cls.norm_dict[name] = func
